/**
 * STRATEGY BUILDER
 * Full-featured strategy builder with 4 tabs:
 * 1. Entry (Long/Short conditions)
 * 2. Exit (TP/SL/Trailing)
 * 3. Indicator (Already exists)
 * 4. Trading Engine (Settings)
 */

// Global strategy configuration
let strategyConfig = {
    name: 'My Strategy',
    description: '',
    indicators: [],
    entry_conditions: {
        long: [],
        short: []
    },
    exit_rules: {
        long: {
            tp_points: 10,
            sl_points: 20,
            trailing_type: 'fixed',
            trailing_points: 5,
            dynamic_tp_sl: false,
            time_exit: '14:30',
            tp_sl_table: []
        },
        short: {
            tp_points: 10,
            sl_points: 20,
            trailing_type: 'fixed',
            trailing_points: 5,
            dynamic_tp_sl: false,
            time_exit: '14:30',
            tp_sl_table: []
        }
    },
    trading_engine: {
        entry_price_type: 'C',
        entry_after_candle: [1],
        position_mode: 'long_only',
        exit_methods: ['signal', 'tpsl', 'time']
    },
    risk_management: {
        max_positions: 1,
        position_size_pct: 10,
        max_daily_loss: 50,
        trading_hours: {
            start: '09:00',
            end: '14:30'
        }
    }
};

// Current editing state
let currentEntryDirection = 'long';
let currentExitDirection = 'long';

/**
 * Initialize Strategy Builder
 */
function initStrategyBuilder() {
    console.log('ðŸŽ¯ Initializing Strategy Builder...');
    
    // Load saved strategy from localStorage if exists
    const saved = localStorage.getItem('currentStrategy');
    if (saved) {
        try {
            strategyConfig = JSON.parse(saved);
            console.log('âœ… Loaded saved strategy:', strategyConfig.name);
        } catch (e) {
            console.error('Error loading saved strategy:', e);
        }
    }
    
    // Render UI
    renderStrategyInfo();
    renderEntryTab();
    renderExitTab();
    renderTradingEngineTab();
    
    console.log('âœ… Strategy Builder initialized');
}

/**
 * Switch between main tabs
 */
function switchPanel(panelName) {
    // Hide all panels
    document.querySelectorAll('.panel-content').forEach(panel => {
        panel.classList.add('hidden');
    });
    
    // Remove active from all tabs
    document.querySelectorAll('.panel-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Show selected panel
    const panelMap = {
        'entry': 'entryPanel',
        'exit': 'exitPanel',
        'indicators': 'indicatorsTabPanel',
        'settings': 'settingsPanel'
    };
    
    const panelId = panelMap[panelName];
    if (panelId) {
        document.getElementById(panelId)?.classList.remove('hidden');
    }
    
    // Add active to clicked tab
    event.target.classList.add('active');
}

/**
 * Render Strategy Info
 */
function renderStrategyInfo() {
    const nameInput = document.getElementById('strategyName');
    const descInput = document.getElementById('strategyDescription');
    
    if (nameInput) nameInput.value = strategyConfig.name;
    if (descInput) descInput.value = strategyConfig.description;
}

/**
 * Update strategy name/description
 */
function updateStrategyInfo() {
    const nameInput = document.getElementById('strategyName');
    const descInput = document.getElementById('strategyDescription');
    
    if (nameInput) strategyConfig.name = nameInput.value;
    if (descInput) strategyConfig.description = descInput.value;
    
    saveToLocalStorage();
}

// ==================== ENTRY TAB ====================

function renderEntryTab() {
    renderConditions('long');
    renderConditions('short');
}

function switchEntryDirection(direction) {
    currentEntryDirection = direction;
    
    // Update tab styles
    const longTab = document.getElementById('longEntryTab');
    const shortTab = document.getElementById('shortEntryTab');
    const longContent = document.getElementById('longEntryContent');
    const shortContent = document.getElementById('shortEntryContent');
    
    if (direction === 'long') {
        longTab?.classList.add('active');
        shortTab?.classList.remove('active');
        longContent?.classList.remove('hidden');
        shortContent?.classList.add('hidden');
    } else {
        longTab?.classList.remove('active');
        shortTab?.classList.add('active');
        longContent?.classList.add('hidden');
        shortContent?.classList.remove('hidden');
    }
}

function renderConditions(direction) {
    const container = document.getElementById(direction === 'long' ? 'longConditions' : 'shortConditions');
    if (!container) return;
    
    const conditions = strategyConfig.entry_conditions[direction];
    
    if (conditions.length === 0) {
        container.innerHTML = '<p style="color: #787b86; padding: 20px; text-align: center;">No conditions yet. Click "Add Condition" below.</p>';
        return;
    }
    
    let html = '';
    conditions.forEach((group, groupIndex) => {
        html += `
            <div class="condition-group" style="background: #1e222d; padding: 15px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid ${direction === 'long' ? '#26a69a' : '#ef5350'};">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4 style="margin: 0; color: #d1d4dc;">${group.name || (direction === 'long' ? 'Buy' : 'Short') + (groupIndex + 1)}</h4>
                    <button onclick="removeConditionGroup('${direction}', ${groupIndex})" style="background: transparent; border: none; color: #ef5350; cursor: pointer; font-size: 18px;">Ã—</button>
                </div>
        `;
        
        group.conditions.forEach((cond, condIndex) => {
            html += `
                <div style="background: #131722; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 12px; color: #d1d4dc;">
                    ${cond.left} ${cond.operator} ${cond.right}
                    ${condIndex < group.conditions.length - 1 ? '<span style="color: #2962ff; font-weight: 600;"> ' + cond.logic + ' </span>' : ''}
                </div>
            `;
        });
        
        html += `</div>`;
    });
    
    container.innerHTML = html;
}

function addCondition(direction) {
    // Simple implementation: add a basic condition
    const newCondition = {
        name: (direction === 'long' ? 'Buy' : 'Short') + (strategyConfig.entry_conditions[direction].length + 1),
        conditions: [
            {
                left: 'close',
                leftOffset: 0,
                operator: '>',
                right: 'open',
                rightOffset: 0,
                logic: 'AND'
            }
        ]
    };
    
    strategyConfig.entry_conditions[direction].push(newCondition);
    renderConditions(direction);
    saveToLocalStorage();
}

function removeConditionGroup(direction, groupIndex) {
    if (confirm('Remove this condition group?')) {
        strategyConfig.entry_conditions[direction].splice(groupIndex, 1);
        renderConditions(direction);
        saveToLocalStorage();
    }
}

// ==================== EXIT TAB ====================

function renderExitTab() {
    renderTPSLConfig('long');
    renderTPSLConfig('short');
}

function switchExitDirection(direction) {
    currentExitDirection = direction;
    
    const longTab = document.getElementById('longExitTab');
    const shortTab = document.getElementById('shortExitTab');
    const longContent = document.getElementById('longExitContent');
    const shortContent = document.getElementById('shortExitContent');
    
    if (direction === 'long') {
        longTab?.classList.add('active');
        shortTab?.classList.remove('active');
        longContent?.classList.remove('hidden');
        shortContent?.classList.add('hidden');
    } else {
        longTab?.classList.remove('active');
        shortTab?.classList.add('active');
        longContent?.classList.add('hidden');
        shortContent?.classList.remove('hidden');
    }
}

function renderTPSLConfig(direction) {
    // Update input values
    const tpInput = document.getElementById(direction === 'long' ? 'tpBuyPoints' : 'tpShortPoints');
    const slInput = document.getElementById(direction === 'long' ? 'stopLossPoints' : 'slShortPoints');
    const trailingInput = document.getElementById(direction === 'long' ? 'fixedTrailingBuyPoints' : 'fixedTrailingShortPoints');
    
    const exitRules = strategyConfig.exit_rules[direction];
    
    if (tpInput) tpInput.value = exitRules.tp_points || 10;
    if (slInput) slInput.value = exitRules.sl_points || 20;
    if (trailingInput) trailingInput.value = exitRules.trailing_points || 5;
}

function renderTPSLTable(direction) {
    const tableBody = document.getElementById('dynamicTierTable');
    if (!tableBody) return;
    
    const table = strategyConfig.exit_rules[direction].tp_sl_table || [];
    
    let html = '';
    table.forEach((tier, index) => {
        html += `
            <tr style="border-bottom: 1px solid #2a2e39;">
                <td style="padding: 10px;">${tier.profit_range[0]}</td>
                <td style="padding: 10px;">${tier.profit_range[1]}</td>
                <td style="padding: 10px;">${tier.trailing}%</td>
                <td style="padding: 10px;">
                    <button onclick="removeDynamicTier(${index})" style="background: transparent; border: none; color: #ef5350; cursor: pointer;">Delete</button>
                </td>
            </tr>
        `;
    });
    
    tableBody.innerHTML = html || '<tr><td colspan="4" style="padding: 20px; text-align: center; color: #787b86;">No tiers yet</td></tr>';
}

function addDynamicTier() {
    const direction = currentExitDirection;
    const table = strategyConfig.exit_rules[direction].tp_sl_table;
    
    const lastTier = table[table.length - 1];
    const nextMin = lastTier ? lastTier.profit_range[1] : 0;
    
    table.push({
        profit_range: [nextMin, nextMin + 3],
        tp: 10,
        sl: 5,
        trailing: 3
    });
    
    renderTPSLTable(direction);
    saveToLocalStorage();
}

function removeDynamicTier(index) {
    const direction = currentExitDirection;
    strategyConfig.exit_rules[direction].tp_sl_table.splice(index, 1);
    renderTPSLTable(direction);
    saveToLocalStorage();
}

// ==================== TRADING ENGINE TAB ====================

function renderTradingEngineTab() {
    // Set radio buttons based on config
    const entryPriceType = strategyConfig.trading_engine.entry_price_type;
    const radios = document.querySelectorAll('input[name="entryPriceType"]');
    radios.forEach(radio => {
        radio.checked = radio.value === entryPriceType;
    });
    
    // Set entry after candle checkboxes
    const entryAfter = strategyConfig.trading_engine.entry_after_candle;
    document.getElementById('entryAfter1').checked = entryAfter.includes(1);
    document.getElementById('entryAfter2').checked = entryAfter.includes(2);
    
    // Set position mode
    const positionMode = strategyConfig.trading_engine.position_mode;
    const positionRadios = document.querySelectorAll('input[name="positionMode"]');
    positionRadios.forEach(radio => {
        radio.checked = radio.value === positionMode;
    });
}

function updateTradingEngine() {
    // Update entry price type
    const entryPriceType = document.querySelector('input[name="entryPriceType"]:checked')?.value;
    if (entryPriceType) {
        strategyConfig.trading_engine.entry_price_type = entryPriceType;
    }
    
    // Update entry after candle
    const entryAfter = [];
    if (document.getElementById('entryAfter1')?.checked) entryAfter.push(1);
    if (document.getElementById('entryAfter2')?.checked) entryAfter.push(2);
    strategyConfig.trading_engine.entry_after_candle = entryAfter;
    
    // Update position mode
    const positionMode = document.querySelector('input[name="positionMode"]:checked')?.value;
    if (positionMode) {
        strategyConfig.trading_engine.position_mode = positionMode;
    }
    
    saveToLocalStorage();
}

// ==================== AUTO GENERATE ====================

function openAutoGenerateModal() {
    const modal = document.getElementById('autoGenerateModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

function closeAutoGenerateModal() {
    const modal = document.getElementById('autoGenerateModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

async function generateStrategy() {
    const longSignals = parseInt(document.getElementById('autoGenLongSignals')?.value || 2);
    const shortSignals = parseInt(document.getElementById('autoGenShortSignals')?.value || 2);
    const indicatorsPerSignal = parseInt(document.getElementById('autoGenIndicatorsPerSignal')?.value || 2);
    const profitLevels = parseInt(document.getElementById('autoGenProfitLevels')?.value || 4);
    const profitStep = parseInt(document.getElementById('autoGenProfitStep')?.value || 3);
    const keepIndicators = document.getElementById('autoGenKeepIndicators')?.checked !== false;
    const randomizeTPSL = document.getElementById('autoGenRandomizeTPSL')?.checked !== false;
    
    try {
        console.log('ðŸ¤– Generating strategy...');
        
        const response = await fetch('/api/auto-generate-strategy', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                current_strategy: strategyConfig,
                long_signals: longSignals,
                short_signals: shortSignals,
                indicators_per_signal: indicatorsPerSignal,
                profit_levels: profitLevels,
                profit_step: profitStep,
                keep_indicators: keepIndicators,
                randomize_tpsl: randomizeTPSL
            })
        });
        
        const data = await response.json();
        
        if (data.success && data.strategy) {
            strategyConfig = data.strategy;
            
            // Re-render all tabs
            renderStrategyInfo();
            renderEntryTab();
            renderExitTab();
            renderTradingEngineTab();
            
            saveToLocalStorage();
            closeAutoGenerateModal();
            
            alert('âœ… Strategy Generated!\n\n' +
                  'ðŸ“ˆ Long Entries: ' + data.strategy.entry_conditions.long.length + '\n' +
                  'ðŸ“‰ Short Entries: ' + data.strategy.entry_conditions.short.length + '\n' +
                  'ðŸ’¹ Profit Levels: ' + data.strategy.exit_rules.long.tp_sl_table.length);
        } else {
            alert('âŒ Error: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error generating strategy:', error);
        alert('âŒ Failed to generate strategy');
    }
}

// ==================== SAVE / LOAD ====================

function newStrategy() {
    if (confirm('Create new strategy? Current strategy will be cleared.')) {
        strategyConfig = {
            name: 'New Strategy',
            description: '',
            indicators: [],
            entry_conditions: {long: [], short: []},
            exit_rules: {
                long: {tp_points: 10, sl_points: 20, trailing_points: 5, dynamic_tp_sl: false, time_exit: '14:30', tp_sl_table: []},
                short: {tp_points: 10, sl_points: 20, trailing_points: 5, dynamic_tp_sl: false, time_exit: '14:30', tp_sl_table: []}
            },
            trading_engine: {entry_price_type: 'C', entry_after_candle: [1], position_mode: 'long_only', exit_methods: ['signal', 'tpsl', 'time']},
            risk_management: {max_positions: 1, position_size_pct: 10, max_daily_loss: 50, trading_hours: {start: '09:00', end: '14:30'}}
        };
        
        renderStrategyInfo();
        renderEntryTab();
        renderExitTab();
        renderTradingEngineTab();
        saveToLocalStorage();
    }
}

async function saveStrategy() {
    updateStrategyInfo();
    
    try {
        const response = await fetch('/api/strategies', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(strategyConfig)
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            alert('âœ… Strategy saved: ' + data.filename);
        } else {
            alert('âŒ Error: ' + data.message);
        }
    } catch (error) {
        console.error('Error saving strategy:', error);
        alert('âŒ Failed to save strategy');
    }
}

async function loadStrategy() {
    try {
        // Get list of strategies
        const response = await fetch('/api/strategies');
        const data = await response.json();
        
        if (data.status === 'success' && data.strategies.length > 0) {
            // Show selection dialog
            let options = 'Select a strategy:\n\n';
            data.strategies.forEach((s, i) => {
                options += `${i + 1}. ${s.name}\n`;
            });
            
            const selection = prompt(options);
            if (selection) {
                const index = parseInt(selection) - 1;
                if (index >= 0 && index < data.strategies.length) {
                    const filename = data.strategies[index].filename;
                    
                    // Load selected strategy
                    const loadResponse = await fetch(`/api/strategies/${filename}`);
                    const loadData = await loadResponse.json();
                    
                    if (loadData.status === 'success') {
                        strategyConfig = loadData.strategy;
                        
                        renderStrategyInfo();
                        renderEntryTab();
                        renderExitTab();
                        renderTradingEngineTab();
                        saveToLocalStorage();
                        
                        alert('âœ… Strategy loaded: ' + strategyConfig.name);
                    }
                }
            }
        } else {
            alert('No saved strategies found');
        }
    } catch (error) {
        console.error('Error loading strategy:', error);
        alert('âŒ Failed to load strategy');
    }
}

function clearStrategy() {
    if (confirm('Clear all conditions?')) {
        strategyConfig.entry_conditions.long = [];
        strategyConfig.entry_conditions.short = [];
        renderEntryTab();
        saveToLocalStorage();
    }
}

function testStrategy() {
    alert('Test Strategy feature - Coming soon!\n\nThis will backtest your strategy on current chart data.');
}

function refreshSignals() {
    alert('Refresh Signals feature - Coming soon!\n\nThis will recalculate and display signals on the chart.');
}

// ==================== UTILITIES ====================

function saveToLocalStorage() {
    try {
        localStorage.setItem('currentStrategy', JSON.stringify(strategyConfig));
    } catch (e) {
        console.error('Error saving to localStorage:', e);
    }
}

// Initialize on page load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initStrategyBuilder);
} else {
    initStrategyBuilder();
}
